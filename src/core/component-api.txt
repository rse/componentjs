##
##  ComponentJS -- Component System for JavaScript <http://componentjs.com>
##  Copyright (c) 2009-2013 Ralf S. Engelschall <http://engelschall.com>
##
##  This Source Code Form is subject to the terms of the Mozilla Public
##  License, v. 2.0. If a copy of the MPL was not distributed with this
##  file, You can obtain one at http://mozilla.org/MPL/2.0/.
##

API Management
--------------

Change the API symbol in the global variable namespace under which ComponentJS
is exposed. By default ComponentJS is exposed under the symbol name
C<ComponentJS>. It is a common convention to change the symbol to C<cs> (for
"component system/service") to have a convenient short-hand.

- ComponentJS.M<symbol>([P<name>: T<String>]): T<ComponentJS>

  Change symbol of ComponentJS API to global variable P<name> and return it.
  If P<name> is not given, ComponentJS does not occupy any global namespace slot at all --
  then it is required to store the return value and use ComponentJS directly through it.

  | ComponentJS.symbol("cs")        /* standard    */
  | var cs = ComponentJS.symbol()   /* alternative */

- ComponentJS.M<version> = {
      F<major>: T<Number>, F<minor>: T<Number>, F<micro>: T<Number>, F<date>:  T<Number>
  }

  Access the ComponentJS implementation version "F<major>C<.>F<minor>C<.>F<micro>"
  and the corresponding release F<date> (in format YYYYMMDD).

  | if (ComponentJS.version.date &lt; 20120101)
  |      throw new Error("need at least ComponentJS as of 20120101")

Library Management
------------------

ComponentJS can be extended through plugins, so it can initialize
some of its internals only once all plugins were loaded and executed.

- ComponentJS.M<bootstrap>(): T<Void>

  Bootstrap the ComponentJS library by initializing its internals.
  This has to be called at least before any calls to M<create>(),
  but can be called after any calls to M<symbol>(), M<debug>() or M<ns>().

  | cs.bootstrap()

- ComponentJS.M<shutdown>(): T<Void>

  Shutdown the ComponentJS library by destroying its internals.
  This implicitly destroy the existing component tree, too.

  | cs.shutdown()

- ComponentJS.M<plugin>(): T<String[]>;
  ComponentJS.M<plugin>(P<name>: T<String>): T<Boolean>;
  ComponentJS.M<plugin>(P<name>: T<String>, P<callback>: T<Function>): T<Void>

  Return the names of all registered plugins, check for the
  registration of a particular plugin with name P<name> or register
  a new plugin under name P<name> with callback function P<callback>.
  The callback function P<callback> should have the signature
  "P<callback>(P<_cs>: T<ComponentJS_API_internal>, P<$cs>:
  T<ComponentJS_API_external>, P<GLOBAL>: T<Environment>): T<Void>" where P<_cs> is the internal ComponentJS
  API (you have to check the source code of ComponentJS to know
  what you can do with it), P<$cs> is the external ComponentJS API
  (the one described in this document) and P<GLOBAL> is the global
  environment object (usually C<window> in a browser, C<global> in
  Node.js, etc).

  | /*  add a "foo()" method to all components  */
  | ComponentJS.plugin("foo", function (_cs, $cs, GLOBAL) {
  |     var trait = $cs.trait({
  |         protos: {
  |             foo: function () {
  |                 ...
  |             }
  |         }
  |     });
  |     _cs.latch("ComponentJS:bootstrap:comp:mixin", function (mixins) {
  |         mixins.push(trait);
  |     });
  | });

Debugging
---------

ComponentJS has special support for debugging its run-time processing,
especially for visualizing the current component tree in real-time.

- ComponentJS.M<debug>(): T<Number>;
  ComponentJS.M<debug>(P<level>: T<Number>): T<Void>;
  ComponentJS.M<debug>(P<level>: T<Number>, P<message>: T<String>): T<Void>

  Get current debug level, or configure the debugging through maximum debug-level P<level>
  (C<0> disables all debug messages, C<9> enables all debug messages) or log a particular
  P<message> under debug-level P<level>.

  | cs.debug(0)
  | if (cs.plugin("debugger")) {
  |     if (cs.debug_instrumented()) {
  |          cs.debug(9)
  |          cs.debug_window({ ... })
  |     }
  | }

- ComponentJS.M<debug_instrumented>(): T<Boolean>

  [AVAILABLE THROUGH THE COMPONENTJS PLUGIN "debugger" ONLY]
  Determine whether the current browser is "instrumented" for debugging, i.e., whether
  the browser's built-in debugger is activated (in detached mode only). Currently
  ComponentJS is able to determine Firefox's Firebug and Chrome's Inspector only.

  | if (cs.debug_instrumented()) ...

- ComponentJS.M<debug_window>({
      F<enable>: T<Boolean>,
      F<autoclose>: T<Boolean>,
      F<name>: T<String>,
      F<width>: T<Number> = 800,
      F<height>: T<Number> = 600,
      F<natural>: T<Boolean> = false
  });
  ComponentJS.M<debug_window>(
      P<enable>: T<Boolean>,
      P<autoclose>: T<Boolean>,
      P<name>: T<String>)

  [AVAILABLE THROUGH THE COMPONENTJS PLUGIN "debugger" ONLY]
  On F<enable> C<true>/C<false> open/close the extra browser window
  containing the ComponentJS debugger view for the ComponentJS application
  identified by F<name>. If F<autoclose> is C<true>,
  optionally automatically close the debugger window with application window
  (which usually is inconvenient during debugging because on application
  reloads the ComponentJS debugger window is recreated with default width/height
  at default position instead of reused). Parameters F<width> and F<height> can be
  used to change the initial window size. Parameter F<natural> controls whether
  the component tree is drawn with the root component at the bottom (C<true>)
  or at the top (C<false>).

  | cs.debug_window({
  |     enable: true,
  |     autoclose: false,
  |     name "My App"
  |     width: 800,
  |     height: 800,
  |     natural: true
  | })

Code Structuring
----------------

ComponentJS internally uses a few code structuring utility functions for implementing
class method parameters and class attributes. Those utility functions
are also exposed for consumption by application developers, but they are
NOT(!) required for using ComponentJS. Especially, it is NOT(!) required
that component backing objects are defined by C<cs.clazz>!

- ComponentJS.M<ns>(P<path>: T<String>[, P<leaf>: T<Object> = {}]): T<Object>

  Classes and traits should be structured through namespaces. A namespace is a
  JavaScript (hash) object, potentially itself part of a parent namespace
  object. The top-most implicit namespace object is C<window>. A namespace has a
  dot-separated fully-qualified symbol path like C<foo.bar.quux>. This
  method allows to create the fully-qualified path of nested objects through the
  dot-separated P<path> of object names, optionally assign the
  right-most/leaf object to P<leave> and finally return the right-most/leaf T<Object>.

  | cs.ns("my.app"); my.app.ui = cs.clazz({ ... })  /* standard    */
  | cs.ns("my.app").ui = cs.clazz({ ... })          /* alternative */
  | cs.ns("my.app.ui", cs.clazz({ ... })            /* alternative */

- ComponentJS.M<select>(P<object>: T<Object>, P<path>: T<String>[, P<value>: T<Object>]): T<Object>

  Dereference into (and this way subset) P<object> according to the
  P<path> specification and either return the dereferenced value or
  set a new P<value>. Object has to be a hash or array object. The
  P<path> argument has to follow the following grammar (which is a
  direct JavaScript dereferencing syntax):

  + path       + ::= + segment segment*
  + segment    + ::= + bybareword | bykey
  + bybareword + ::= + "C<.>"? identifier
  + bykey      + ::= + "C<[>" key "C<]>"
  + identifier + ::= + /C<[_a-zA-Z$][_a-zA-Z$0-9]*>/
  + key        + ::= + number | squote | dquote
  + number     + ::= + /C<[0-9]+>/
  + dquote     + ::= + /C<"(?:\\"|.)*?">/
  + squote     + ::= + /C<'(?:\\'|.)*?'>/

  Setting the P<value> to C<undefined> effectively removes the
  dereferenced value. If the dereferenced parent object is a hash, this
  means the value is C<delete>'ed from it. If the dereferenced parent
  object is an array, this means the value is C<splice>'ed out of it.

  | cs.select({ foo: { bar: { baz: [ 42, 7, "Quux" ] } } }, "foo['bar'].baz[2]") -> "Quux"

- ComponentJS.M<validate>(P<object>: T<Object>, P<spec>: T<String>[, P<path>: T<String>]): T<Boolean>

  Validate an arbitrary nested JavaScript object P<object> against the
  textual specification P<spec> (optionally subset with the JSON path
  P<path>). The specification has to follow the following grammar (which
  is a mixture of JSON-like structure and RegExp-like quantifiers):

  + spec      + ::= + not | alt | hash | array | any | primary | class | special
  + not       + ::= + "C<!>" spec
  + alt       + ::= + "C<(>" spec ("C<|>" spec)* "C<)>"
  + hash      + ::= + "C<{>" (key arity? "C<:>" spec ("C<,>" key arity? "C<:>" spec)*)? "C<}>"
  + array     + ::= + "C<[>" (spec arity? ("C<,>" spec arity?)*)? "C<]>"
  + arity     + ::= + "C<?>" | "C<*>" | "C<+>"
  + key       + ::= + /C<^[_a-zA-Z$][_a-zA-Z$0-9]*$>/
  + any       + ::= + "C<any>"
  + primary   + ::= + /C<^(?:null|undefined|boolean|number|string|function|object)$>/
  + class     + ::= + /C<^[A-Z][_a-zA-Z$0-9]*$>/
  + special   + ::= + /C<^(?:clazz|trait|component)$>/

  The optional P<path> has to follow the same grammar as the P<path> argument
  of the M<select> method and allows you to validate P<object> against
  a subset of P<spec>.

  | cs.validate({ foo: "Foo", bar: "Bar", baz: [ 42, 7, "Quux" ] },
  |      "{ foo: string, bar: any, baz: [ number+, string* ], quux?: any }")

- ComponentJS.M<params>(P<name>: T<String>, P<args>: T<Object[]>, P<spec>: T<Object>): T<Object>

  Handle positional and named function parameters by processing
  a function's C<arguments> array. Parameter P<name> is the name
  of the function for use in exceptions in case of invalid parameters.
  Parameter P<args> usually is the JavaScript C<arguments> pseudo-array of
  a function. Parameter P<spec> is the parameter specification: each key
  is the name of a parameter and the value has to be an T<Object> with
  the following possible fields: P<pos> for the optional position in case
  of positional usage, P<def> for the default value (of not required
  and hence optional parameters), P<req> to indicate whether the
  parameter is required and P<valid> for type validation (either
  a string accepted by the M<validate>() method,
  or a valid regular expression C</.../>
  for validating a T<String> against it or an arbitrary callback function.

  | function config () {
  |     var params = $cs.params("config", arguments, {
  |         scope: { pos: 0, req: true,      valid: "boolean"           },
  |         key:   { pos: 1, req: true,      valid: /^[a-z][a-z0-9_]*$/ },
  |         value: { pos: 2, def: undefined, valid: "object"            },
  |         force: {         def: false,     valid: "boolean"           }
  |     });
  |     var result = db_get(params.scope, params.key);
  |     if (typeof params.value !== "undefined")
  |         db_set(params.scope, params.key, params.value, params.force);
  |     return result;
  | }
  | var value = config("foo", "bar");
  | config("foo", "bar", "quux");
  | config({ scope: "foo", key: "bar", value: "quux", force: true });

- ComponentJS.M<attribute>({ F<name>: T<String>, F<def>: T<Object>, F<validate>: T<Object> }): T<Function>;
  ComponentJS.M<attribute>(P<name>: T<String>, P<def>: T<Object>, P<validate>: T<Object>): T<Function>

  Create a cloneable attribute capturing getter/setter function with name P<name> (for exception
  handling reasons only), the default value P<def> and the value validation P<validate>.

  | var id = ComponentJS.attribute("id", "foo", /^[a-z][a-zA-Z0-9_]*/);
  | id() === "foo"
  | id("bar") -> "foo"; id() -> "bar"

- ComponentJS.M<clazz>({
        [F<name>:        T<String>,]
        [F<extend>:      T<Clazz>,]
        [F<mixin>:       T<Array(Trait)>,]
        [F<cons>:        T<Function>,]
        [F<dynamics>:    T<Object>,]
        [F<protos>:      T<Object>,]
        [F<statics>:     T<Object>]
  }): T<Clazz>

  Define a JavaScript Class, optionally stored under the absolute dot-separated
  object path F<name>, optionally extending the base/super/parent Class F<extend>
  and optionally mixing in the functionality of one or more Traits via F<mixin>. The class
  can have a constructor function F<cons> which is called once the
  Class is instantiated and which can further initialize the dynamic fields of the class.
  On each instantiation, all fields which are specified with F<dynamics> are
  cloned and instantiated and all methods in F<protos> are copied into the
  Class C<prototypes> object. The F<statics> content is copied into the
  Class itself only. In case of F<extend> and/or F<mixin>, both the F<cons>
  and methods of F<protos> can call C<this.base(...)> for the base/super/parent
  method.

  | var foo = cs.clazz({
  |     cons: function (bar) {
  |         this._bar = bar;
  |     },
  |     protos: {
  |         bar: function (value_new) {
  |             var value_old = this._bar;
  |             if (typeof value_new !=== "undefined")
  |                 this._bar = value_new;
  |             return value_old;
  |         }
  |         [...]
  |     }
  | })

  It is important to notice how calls to any method resolve and how
  calls to C<this.base()> in any method of a class resolves. When on
  class C<Foo> and its instanciated object C<foo> a method C<foo.bar()>
  is called, the following happens:

  . First, a direct property named C<bar> on object C<foo> is tried.
    This can exist on C<foo> through (in priority order) a C<bar> in
    either the F<dynamics> definition of a F<mixin> of C<Foo>, or in the
    F<statics> definition of a F<mixin> of C<Foo>, or in the F<dynamics>
    definition of C<Foo>, or in the F<statics> definition of C<Foo>.

  . Second, an indirect prototype-based property named C<bar> on object
    C<foo> is tried. This can exist on C<foo> through (in priority order)
    a C<bar> in either the F<protos> definition of C<Foo> or in the
    F<protos> definition of any F<extend> of C<Foo>.

  When on class C<Foo> and its instanciated object C<foo> in any method C<foo.bar()>
  the C<this.base()> is called, the following happens:

  . First, a call to the super/base/parent functions in the F<mixin> trait chain is attempted.
    The mixins are traversed in the reverse order of the trait specification in the
    F<mixin> array, i.e., the last trait's mixins are tried first.

  . Second, a call to the super/base/parent functions in the F<extend>
    inheritance class chain is attempted. First, the directly F<extend>
    class is attempted, then the F<extend> class of this class, etc.

  NOTICE: As ComponentJS does not care at all how backing objects of
  components are defined, you can alternatively use an arbitrary
  solution for Class-based OO in JavaScript (e.g. TypeScript, JSClass,
  ExtendJS, DejaVu, Classy, jTypes, etc) or fallback to the also just
  fine regular Prototype-based OO in JavaScript:

  | var foo = function (bar) {
  |     this._bar = bar;
  | }
  | foo.prototype.bar = function (value_new) {
  |     var value_old = this._bar;
  |     if (typeof value_new !=== "undefined")
  |         this._bar = value_new;
  |     return value_old;
  | }
  | [...]

- ComponentJS.M<trait>({
        [F<name>:        T<String>,]
        [F<mixin>:       T<Array(Trait)>,]
        [F<cons>:        T<Function>,]
        [F<setup>:       T<Function>,]
        [F<dynamics>:    T<Object>,]
        [F<protos>:      T<Object>,]
        [F<statics>:     T<Object>]
  }): T<Trait>

  Define a JavaScript Trait (a Class which can be mixed in), optionally stored under the absolute dot-separated
  object path F<name> and
  optionally mixing in the functionality of one or more other Traits via F<mixin>. The trait
  can have a constructor function F<cons> which is called once the
  Class the Trait is mixed in is instantiated and which can further initialize the dynamic fields of the Class.
  On each instantiation, all fields which are specified with F<dynamics> are
  cloned and instantiated and all methods in F<protos> are copied into the
  Class C<prototypes> object. The F<statics> content is copied into the
  Class itself only. The optional F<setup> function is called directly at the end of Class
  definition (not instantiation) and can further refine the defined Class.

  | var foo = cs.trait({
  |     protos: {
  |         bar: function () {
  |             [...]
  |         }
  |     }
  | })

Component Creation
------------------

Components are managed in hierarchical fashion within a component tree.
The component tree can be traversed and its components can be created,
looked up, state transitioned, communicated on and be destroyed.

- ComponentJS.M<create>(P<abs-tree-spec>: T<String>, P<class>: T<Class>[, ...]): T<Object>;
  ComponentJS.M<create>(P<base>: T<Component>, P<rel-tree-spec>: T<String>, P<class>: T<Class>[, ...]): T<Object>;
  O<component>.M<create>(P<rel-tree-spec>: T<String>, P<class>: T<Class>[, ...]): T<Object>

  Create one or more components. Their structure is specified by the
  absolute (P<abs-tree-spec>) or relative (P<rel-tree-spec>) tree specification
  which is string containing a set (C<{...}>) of slash-separated (C<.../...>) paths
  of component names. In other words, the specification has to follow the
  following grammar:

  + abs-tree-spec + ::= + "/" rel-tree-spec
  + rel-tree-spec + ::= + path | "C<{>" path ("C<,>" path)* "C<}>"
  + path          + ::= + rel-tree-spec | name ("/" name)*
  + name          + ::= + /C<^[^\/]+$>/

  For instance, the specification C<foo/{bar/baz,quux}> is the
  tree consisting of the two maximum length paths: C<foo/bar/baz> and C<foo/quux>.
  For each name from left-to-right in the tree specification you have to give
  either a to be instantiated class constructor (T<Function>) or an already
  instantiated object (T<Object>).

  The M<create>() method returns the last created component, i.e., the
  right-most component in the tree specification.

  | cs.create("/{sv,ui/{one,two}}", my.sv, {}, my.ui.one, my.ui.two);
  | cs.create(this, "model/view", model, view);
  | cs(this).create("model/view", model, view);

- ComponentJS.M<destroy>(P<abs-path>: T<String>): T<Void>;
  O<component>.M<destroy>(): T<Void>;
  O<component>.M<destroy>(): T<Void>

  Destroy the component uniquely identified by P<abs-path> or
  the O<component> on which this method is called upon.

  | cs.destroy("/foo/bar")
  | cs.destroy(comp, "foo/bar")
  | cs("/foo/bar").destroy()

Component Information
---------------------

Components carry a few distinct information. They can be
accessed via the following getter/setter-style methods.

- O<component>.M<id>(): T<String>;
  O<component>.M<id>(P<id>: T<String>): T<String>

  Get current unique id of O<component> or set new P<id> on O<component> and return
  the old id. Setting the id of a component should be not done by the application
  as it is done by ComponentJS internally on component creation time.

  | cs(this).id() -> "0000000000000000000000000000001"

- O<component>.M<name>(): T<String>;
  O<component>.M<name>(P<name>: T<String>): T<String>

  Get current non-unique name of O<component> or set new P<name> on O<component> and return
  the old name. Setting the name of a component should be not done by the application
  as it is done by ComponentJS internally on component creation time.

  | cs("/foo/bar").name() === "bar"

- O<component>.M<obj>(): T<Object>

  Retrieve the backing T<Object> P<object> to the corresponding T<Component>.

  | cs(this).obj() === this

- O<component>.M<cfg>(): T<Array(String)>;
  O<component>.M<cfg>(P<key>: T<String>): T<Object>;
  O<component>.M<cfg>(P<key>: T<String>, P<value>: T<Object>): T<Object>;
  O<component>.M<cfg>(P<key>: T<String>, C<undefined>): T<Object>

  Components can have key/value pairs attached for application
  configuration purposes. Four use cases exists for this method: 1.
  get array of all key strings, 2. get current configuration property
  identified by P<key>, 3. set configuration property identified by
  P<key> to new value P<value> and return the old value, and 4. delete
  the configuration property identified by P<key>.

  | var value = cs("/foo/bar").cfg("quux")
  | cs("/foo/bar").cfg("quux", value)
  | cs("/foo/bar").cfg("quux", undefined)

Component Lookup
----------------

Before performing certain operations on a component, it first have to
be looked up in the component tree. As this is one of the most prominent
functionalities of ComponentJS, it is directly exposed through the
global API symbol.

- M<ComponentJS>(P<abs-path>: T<string>): T<Component>;
  M<ComponentJS>(P<component>: T<Component>, P<rel-path>: T<String>): T<Component>;
  M<ComponentJS>(P<object>: T<Object>, P<rel-path>: T<String>): T<Component>;
  M<ComponentJS>(P<component>: T<Component>): T<Component>;
  M<ComponentJS>(P<object>: T<Object>): T<Component>

  Components can be looked up by absolute/relative paths
  from root/base components. A path is a string of slash-separated component names
  with four special names allowed: "C<.>" for current component name, "C<..>" for parent
  component name, "C<*>" for any component name and an empty name (C<//>) for
  any component trees between current and following components. In any case, the result has
  to uniquely identify a single component.
  The following usages exist:
  1. Lookup T<Component> by absolute path P<path> (this is usually never done explicitly,
     but occurs implicitly if the input parameter is already a T<Component>).
  2. Lookup T<Component> by path P<path>, relative to T<Component> P<component>.
  3. Lookup T<Component> by path P<path>, relative to the T<Component> corresponding
  to T<Object> P<object>.
  4. Lookup T<Component> object via backing object P<object>.
  5. Lookup T<Component> object via the P<component> itself (no-operation).
  The paths have to follow the following grammar:

  + abs-path + ::= + "/" rel-path
  + rel-path + ::= + name ("/" name)*
  + name     + ::= + "" | "C<*>" | /C<^[^\/]+$>/

  | cs("/foo/bar")           /* absolute */
  | cs(comp, "model/view")   /* relative to component */
  | cs(this, "model/view")   /* relative to component via backing object */
  | cs("//bar")              /* full-tree lookup */
  | cs(comp, "//bar")        /* sub-tree lookup */
  | cs(this, "*/view")       /* wildcard lookup */
  | cs(this, "..//view")     /* parent sub-tree lookup */

- O<component>.M<exists>(): T<Boolean>

  Check whether a (usually previously looked up) O<component> (either a real
  existing on or the special pre-existing singleton component with name "C<&lt;none&gt;>") really
  exists in the component tree.

  | if (cs("//quux").exists()) ...
  | if (cs("//quux").name() !== "&lt;none&gt;") ...

Component Tree
--------------

Components are managed within a component tree.
The following functions allow you to traverse this tree.

- O<component>.M<path>(): T<Array(Component)>;
  O<component>.M<path>(P<separator>: T<String>): T<String>

  Either retrieve as an array all T<Components> from the current O<component>
  up to and including the root component, or get the slash-separated component name path T<String>
  from the root component down to and including the current O<component>.

  | cs("/foo/bar").path("/") -> "/foo/bar"
  | cs("/foo/bar").path() -> [ cs("/foo/bar"), cs("/foo"), cs("/") ]

- O<component>.M<parent>(): T<Component>

  Return the parent component of O<component>, or C<null> if O<component> is the root or none component.

  | cs(this).parent() === cs(this, "..")

- O<component>.M<children>(): T<Array(Component)>

  Return the array of child components of O<component>.

  | cs(this).children()

- O<component>.M<attach>(P<parent>: T<Component>): T<Void>

  Attach O<component> as a child to the P<parent> component. In case
  it is already attached to an old parent component, it automatically
  calls M<detach>() before attaching to the new parent component.
  Internally used by ComponentJS on M<create>(), but can be also used by
  application when moving a sub-tree within the component tree.

  | /*  migrate all children from our view1 onto our view2  */
  | var view1 = cs(this, "model/view1")
  | var view2 = cs(this, "model/view2")
  | view1.children().forEach(function (child) {
  |     var state = child.state({ state: "created", sync: true })
  |     child.detach()
  |     child.attach(view2)
  |     child.state(state)
  | })

- O<component>.M<detach>(): T<Void>

  Detach O<component> as a child from its parent component.
  Internally used by ComponentJS on M<destroy>(), but can be also used by
  application when moving components within the component tree.

  | cs(this).detach()

- O<component>.M<walk_up>(P<callback>: T<Function>, P<ctx>: T<Object>): T<Object>

  Walk the component tree upwards from the current component (inclusive) to
  the root component (inclusive). The P<callback> T<Function> has to be
  of signature P<callback>(P<depth>: T<Number>, P<component>: T<Component>, P<ctx>: T<Object>): T<Object>
  and for each component it is called like "C<ctx = >P<callback>C<(depth++, comp, ctx)>" where
  initially C<ctx=>P<ctx>, C<comp=>O<component> and C<depth=>C<0> was set.

  | var path = cs(this).walk_up("", function (depth, comp, ctx) {
  |     return "/" + comp.name() + ctx;
  | }, "")

- O<component>.M<walk_down>(P<callback>: T<Function>, P<ctx>: T<Object>): T<Object>

  Walk the component tree downwards from the current component (inclusive) to all the transitive child components
  (inclusive). The P<callback> T<Function> has to be of signature P<callback>(P<ctx>: T<Object>, P<component>:
  T<Component>, P<depth>: T<Number>, P<depth_first>: T<Boolean>): T<Object> and for each component it is called twice(!): once
  like "C<ctx = >P<callback>C<(depth, comp, ctx, false)>"  when entering the component (before all children will be
  visited) and once like "C<ctx = >P<callback>C<(depth, comp, ctx, true)>" when leaving a component (after all children
  were visited). Initially C<ctx=>P<ctx>, C<comp=>O<component> and C<depth=>C<0> is set.

  | var output = cs(this).walk_down(
  |     function (depth, comp, output, depth_first) {
  |         if (!depth_first) {
  |             for (var n = 0; n &lt; depth; n++)
  |                 output += "    ";
  |             output += "\"" + comp.name() + "\"\n";
  |         }
  |         return output;
  |     },
  | "")

States
------

Components, during their life-cycle, are in various particular states.
Components can be triggered to change their state. During those state
transitions, enter and leave methods are called accordingly.

- ComponentJS.M<transition>(C<null>);
  ComponentJS.M<transition>(
        P<target>: T<String>,
        P<enter>: T<String>,
        P<leave>: T<String>,
        P<color>: T<String>,
        [P<source>: T<String>]
  );
  ComponentJS.M<transition>({
        F<target>: T<String>,
        F<enter>: T<String>,
        F<leave>: T<String>,
        F<color>: T<String>,
        [F<source>: T<String>]
  })

  Clear all (if passed just a single C<null> parameter) or add one state transition to target state
  P<target>, either at the top of the transition stack or in the middle, above the source state
  P<source>. When entering the target state, the optional component backing object method P<enter> is
  called. When leaving the target state, the optional component backing object method P<leave> is called.
  The P<color> is a "#RRGGBB" string used for visualizing the state in the debugger view. The default
  state transition definitions are given as an example.

  | cs.transition(null);
  | cs.transition("created",      "create",  "destroy",  "#cc3333");
  | cs.transition("configured",   "setup",   "teardown", "#eabc43");
  | cs.transition("prepared",     "prepare", "cleanup",  "#f2ec00");
  | cs.transition("materialized", "render",  "release",  "#6699cc");
  | cs.transition("visible",      "show",    "hide",     "#669933");
  | cs.transition("enabled",      "enable",  "disable",  "#336600");

- O<component>.M<state>(): T<String>;
  O<component>.M<state>(P<state>: T<String>[, P<callback>: T<Function>]): T<String>;
  O<component>.M<state>({
      F<state>: T<String>,
      [F<callback>: T<Function> = undefined,]
      [F<sync>: T<Boolean> = false,]
  }): T<String>

  Determine the current state or request a transition to a new state of O<component>.
  By default a state transition is performed asynchronously, but you
  can request a synchronous transition with F<sync>. For asynchronous
  transitions you can await the transition finish with F<callback>.
  The old state is returned on state transitions.
  On each state transition, for each transitively involved component and each
  target or intermediate state, a non-capturing/non-bubbling event is
  internally published named "C<ComponentJS:state:>F<state>C<:enter>"
  or "C<ComponentJS:state:>F<state>C<:leave>". You can subscribe to those
  in order to react to state transitions from outside the component, too.

  | cs("/ui").state("visible")

- O<component>.M<state_compare>({ F<state>: T<String> }): T<Number>;
  O<component>.M<state_compare>(P<state>: T<String>): T<Number>

  Compare the state of O<component> with F<state>. If O<component> is
  in a lower state than F<state>, a negative number is returned. If
  O<component> is in same state than F<state>, a zero is returned.
  If O<component> is in a higher state than F<state>, a positive number
  is returned.

  | if (cs(this).state_compare("visible") &lt; 0) ...

- O<component>.M<state_auto_increase>(P<increase>: T<Boolean>): T<Boolean>;
  O<component>.M<state_auto_increase>(): T<Boolean>

  Get or set component O<component> to automatically
  transition to same higher/increased state than its
  parent component.

  | cs(this).state_auto_increase(true)

- O<component>.M<state_auto_decrease>(P<decrease>: T<Boolean>): T<Boolean>;
  O<component>.M<state_auto_decrease>(): T<Boolean>

  Get or set component O<component> to automatically
  transition to same lower/decreased state than its
  child components. Notice that this means that a child can
  drag down the parent component and this way implicitly also
  all of its other sibling child components. Hence, use with care!

  | cs(this).state_auto_decrease(true)

- O<component>.M<guard>({ F<method>: T<String>, F<level>: T<Number> }): T<Void>;
  O<component>.M<guard>(P<method>: T<String>, P<level>: T<Number>): T<Void>

  Guard component O<component> from calling the state enter/leave method F<method>
  and this way prevent it from entering/leaving the corresponding state.
  The F<level> can be increased and decreased. Initially it should be set to
  a positive number to activate the guard. Then it should be set to
  a negative number to (potentially) deactivate the guard. A usage with
  an initial call of C<+1> and then followed by a C<-1> is a boolean guard.
  An initial call of C<+N> and then followed by N times a C<-1> call is a Semaphore-like
  guard which ensures that only after the Nth C<-1> call the guard is finally deactivated
  again. This is useful if you activate the guard in order to await N asynchronous operations.
  Then the guard should be deactivated once the last asynchronous operation is finished
  (independent which one of the N operations this is). A guard P<level> of C<0>
  resets the guard, independent what its current level is.

  | var self = this;
  | cs(self).guard("render", +2)
  | $.get(url1, function (data) {
  |     self.data1 = data;
  |     cs(self).guard("render", -1)
  | });
  | $.get(url2, function (data) {
  |     self.data2 = data;
  |     cs(self).guard("render", -1)
  | });

Spools
------

In ComponentJS there are at least 4 resource allocating operations which have corresponding deallocation operations:
Model M<observe>()/M<unobserve>(), Socket M<plug>()/M<unplug>(), Event M<subscribe>()/M<unsubscribe>(), Service and
M<register>()/M<unregister>(). For correct run-time operation it is required that each
allocation operation, performed in a state enter method, is properly reversed with the corresponding deallocation
operation in the state leave method. As this is extremely cumbersome (especially because you have to store the
identifiers returned by the allocation operations as you need them for the deallocation operation), ComponentJS provides
a convenient spool mechanism which all of the above allocation operations support and which also can be used by the
application itself.

- O<component>.M<spool>({
      F<name>: T<String>,
      F<ctx>: T<Object>,
      F<func>: T<Function>,
      [F<args>: T<Array(Object)> = new Array()]
  }): T<Void>;
  O<component>.M<spool>(
      P<name>: T<String>,
      P<ctx>: T<Object>,
      P<func>: T<Function>,
      [P<args>: T<Object>, ...]
  ): T<Void>

  Remember action "F<func>.C<apply>(F<ctx>, F<args>)" on spool named F<name>.
  The F<name> parameter can be either just a plain spool-name "C<name>"
  or a combination of (relative) component-path and spool-name "C<path>:C<name>".
  This allows one to spool on a component different from O<component> (usually
  a relative path back to the component of the caller of the M<spool>() operation).

  | cs(this).spool({
  |     name: "foo",
  |     ctx: this,
  |     func: function (num, str) { ... },
  |     args: [ 42, "foo" ]
  | });

- O<component>.M<spooled>({ F<name>: T<String> }): T<Number>;
  O<component>.M<spooled>(P<name>: T<String>): T<Number>

  Return the number of actions which are spooled under spool named F<name>.
  Usually done before calling M<unspool>() as it would throw an
  exception if there are no spooled actions at all.

  | if (cs(this).spooled("foo"))
  |     cs(this).unspool("foo")

- O<component>.M<unspool>({ F<name>: T<String> }): T<Void>;
  O<component>.M<unspool>(P<name>: T<String>): T<Void>

  Perform all actions previously spooled on spool F<name>
  in reverse spooling order (those spooled last are executed first).

  | release: function () {
  |     cs(this).unspool("materialized")
  | }

Markers
-------

An object can be "marked" with a set of names. ComponentJS internally
does not use those markers at all, but the ComponentJS Debugger plugin
at least uses markers named "service", "model", "view" and "controller" on
a components' backing object to render those components in different colors.

- C<ComponentJS>.M<mark>(P<obj>: T<Object>, P<name>: T<String>): T<Void>;
  O<component>.M<mark>(P<name>: T<String>): T<Void>

  Mark object P<obj> with marker named P<name>.
  An arbitrary number of markers can be added to an object.
  An an alternative and for convenience reasons, but only if the component classes are
  defined through ComponentJS' optional Class/Trait system,
  the traits C<cs.marker.{service,model,view,controller}>
  can be mixed into.

  | app.ui.panel.view = cs.clazz({
  |     create: function () {
  |         cs(this).mark("view");
  |     }
  |     ...
  | });

  | app.ui.panel.view = cs.clazz({
  |     mixin: [ cs.marker.view ]
  |     ...
  | });

- C<ComponentJS>.M<marked>(P<obj>: T<Object>, P<name>: T<String>): T<Boolean>;
  O<component>.M<marked>(P<name>: T<String>): T<Boolean>

  Checks whether object P<obj> is marked with marker named P<name>.
  This is usually interesting for ComponentJS plugin developers only.

  | if (cs("/").marked("controller")) {
  |     ...
  | }

Properties
----------

Every component can have an arbitrary number of key/value based properties attached to it.
The keys have to be of type T<String>, the values can be of any type. A property
is set on a target component but is resolved on both the target component and
all parent components (up to and including the root component). This way properties
feel like inherited and overrideable values which can be used for both storing
component-local information and to communicate information to foreign components.

- O<component>.M<property>({
      F<name>: T<String>,
      [F<value>: T<Object> = C<undefined>,]
      [F<scope>: T<String> = C<undefined>,]
      [F<bubbling>: T<Boolean> = C<true>,]
      [F<targeting>: T<Boolean> = C<true>,]
      [F<returnowner>: T<Boolean> = C<false>]
  }): T<Object>;
  O<component>.M<property>(P<name>: T<String>, P<value>: T<Object>): T<Object>;
  O<component>.M<property>(P<name>: T<String>): T<Object>

  Get or set property with name F<name> and value F<value> on component O<component>.
  If F<bubbling> is set to C<false> a property get operation does not resolve
  on any parent components ("it does not bubble up to the root").
  If F<targeting> is set to C<false> a property get operation does not resolve
  on the target component O<component> (resolving starts on parent component).
  If F<returnowner> is set to F<true> instead of the property value, the
  owning component is returned.
  Finally, properties can be scoped with a child component name or even
  a descendant component name path: on each attempt
  to resolve the property, first the scoped variants are tried. This means,
  if a property was set with F<name> "C<quux@bar>" (or with F<name> "C<quux>" and an
  explicitly F<scope> set to "C<bar>") on component C< /foo>,
  if you resolve the property with C<cs("/foo/bar", "quux")> you
  get the value, but if you resolve the property with C<cs("/foo/baz", "quux")> you
  do not get the value. This allows you to set the same property with different
  values for different child components.
  Additionally the scope can be a partial component path, too.
  If a property was set with name "C<quux@bar/baz>" on component C< /foo>,
  if you resolve the property with C<cs("/foo/bar/baz", "quux")> you
  get the value, but if you resolve the property with C<cs("/foo/bar/baz2", "quux")> you
  do not get the value. This allows you for instance to skip so-called intermediate namespace-only
  components.
  Setting F<value> to "C<null>" removes the property.

  | cs(this).property("foo")

Sockets
-------

Sockets are a special form of component Properties with callback functions as the values. They are intended to link
Views of child/descendant components into the View of a parent/ancestor component. In contrast to regular Properties,
Sockets are never resolved directly on the target component. Instead they always start to resolve on the parent
component because the sockets on the target component are intended for its child/ancestor components and not for the
target component itself. So, please remember to never plug a socket directly onto the target component!

- O<component>.M<socket>({
      [F<name>: T<String> = "default",]
      [F<scope>: T<Object> = null,]
      F<ctx>: T<Object>,
      F<plug>: T<Function>,
      F<unplug>: T<Function>
      [, F<spool>: T<String>]
  }): T<Number>;
  O<component>.M<socket>(
      P<ctx>: T<Object>,
      P<plug>: T<Function>,
      P<unplug>: T<Function>
  ): T<Number>

  Create a socket on O<component>, named F<name> and optionally
  scoped for the child component named F<scope>, where M<plug>()
  and M<unplug>() calls on child/ancestor components execute
  the supplied F<plug>/F<unplug> functions with F<ctx> supplied as
  C<this>, the F<object> parameter of M<plug>()/M<unplug>() as
  first argument and O<component> as the second argument.
  The M<socket>() method returns an id which uniquely identifies the socket.
  Instead of having to manually release the socket later via M<unsocket>()
  you can use the spool mechanism and spool the corresponding M<unsocket>()
  operation via option F<spool>.

  | var ui = $(...);
  | cs(this).socket({
  |     ctx:    ui,
  |     plug:   function (el) { $(this).append(el); },
  |     unplug: function (el) { $(el).remove(); }
  | })

- O<component>.M<unsocket>({ F<id>: T<Number> }): T<Void>;
  O<component>.M<unsocket>(P<id>: T<Number>): T<Void>

  Destroy the socket identified by F<id>, previously created by a call to M<socket>().
  This is usually done implicitly through the spooling mechanism.

  | cs(this).unsocket(id)

- O<component>.M<link>({
      [F<name>: T<String> = "default",]
      [F<scope>: T<Object> = null,]
      F<target>: T<Object>,
      F<socket>: T<String>
      [, F<spool>: T<String>]
  });
  O<component>.M<link>(
      P<target>: T<Object>,
      P<socket>: T<String>
  )

  Create a socket on O<component>, named F<name> and optionally
  scoped for the child component named F<scope>, and pass-through the
  M<plug>()/M<unplug>() calls to the target component F<target>
  and its socket named F<socket>. Usually used by Controller
  components to link their default socket (for the View below itself) to a
  particular socket of a parent component (because a View should be reusable
  and hence is not allowed to know the particular socket intended for it).
  The M<link>() method returns an id which uniquely identifies the linked socket.
  Instead of having to manually release the socket later via M<unlink>()
  you can use the spool mechanism and spool the corresponding M<unlink>()
  operation via option F<spool>.

  | cs(this).link({ name: "default", target: this, socket: "menu1" })

- O<component>.M<unlink>({ F<id>: T<Number> }): T<Void>;
  O<component>.M<unlink>(P<id>: T<Number>): T<Void>

  Destroy the linked socket identified by F<id>, previously created by a call to M<link>().
  This is usually done implicitly through the spooling mechanism.

  | cs(this).unlink(id)

- O<component>.M<plug>({
      [F<name>: T<String> = "default",]
      F<object>: T<Object>,
      [F<spool>: T<String>,]
      [F<targeting>: T<Boolean>]
  }): T<Number>;
  O<component>.M<plug>(P<object>: T<Object>): T<Number>

  Plugs F<object> into the socket named F<name> provided by any
  parent/ancestor component of O<component>. Optionally spool the
  corresponding M<unplug>() operation on spool F<spool> attached to O<component>.
  Optionally (in case of F<targeting> set to C<true>) start the
  operation on O<component> instead of its parent component.
  Returns an identifier for use with the corresponding M<unplug>() operation.

  | cs(this).plug({ object: ui, spool: "materialized" })

- O<component>.M<unplug>({ F<id>: T<Number>[, F<targeting>: T<Boolean>] }): T<Void>;
  O<component>.M<unplug>(P<id>: T<Number>): T<Void>

  Unplugs the object previously plugged under F<id> from the
  socket providing parent/ancestor component of O<component>.
  Optionally (in case of F<targeting> set to C<true>) start the
  operation on O<component> instead of its parent component.
  This is usually performed indirectly through the Spool mechanism.

  | cs(this).unplug(id)

Models
------

When using Model/View/Controller roles for components, the Model
component needs a so-called Presentation Model: an
abstraction of presentation onto which both View and Controller
components attach via Observer pattern. The Controller component
for provisioning business information into the Model and triggering
business services upon Model changes. The View component for
displaying the Model information and storing events into it.

- O<component>.M<model>(P<spec>: T<Object>): T<Object>

  Define a model through the specification in P<spec>. Each key
  is the name of a model element and the value has to be an T<Object> with
  the following possible fields: F<value> (T<Object>) for the default
  value, F<valid> (T<String>/T<RegExp>) for validating the values (based
  on the underlying validation language of the M<validate>() method), F<autoreset> (T<Boolean>) for
  indicating that on each value write, the value should be
  automatically reset to the initial F<value>, and F<store> (T<Boolean>) for
  indicating that the value should be persistently stored in the browser's C<localStorage>.
  Multiple calls to the M<model>() method on the same component incrementally
  add model elements.

  | cs(this).model({
  |     "param:realms":         { value: [],      valid: "[string*]" },
  |     "data:realm":           { value: "",      valid: "string", store: true },
  |     "data:username":        { value: "",      valid: "string", store: true },
  |     "data:password":        { value: "",      valid: "string" },
  |     "state:username":       { value: "empty", valid: "string" },
  |     "state:username-hint":  { value: "",      valid: "string" },
  |     "state:password":       { value: "empty", valid: "string" },
  |     "state:password-hint":  { value: "",      valid: "string" },
  |     "state:hashcode-col":   { value: 0,       valid: "number" },
  |     "state:hashcode-txt":   { value: "",      valid: "string" },
  |     "state:button-enabled": { value: false,   valid: "boolean" },
  |     "event:button-clicked": { value: false,   valid: "boolean", autoreset: true }
  | })

- O<component>.M<value>({
      F<name>: T<String>,
      [F<operation>: T<String>,]
      [F<value>: T<Object>,]
      [F<force>: T<Boolean>]
  });
  O<component>.M<value>(
      P<name>: T<String>,
      [P<value>: T<Object>,]
      [P<force>: T<Boolean>]
  )

  Get the value of O<component>'s model element named F<name> or
  set the value of O<component>'s model element named F<name> to F<value>.
  As each value change causes observers to be triggered, by default
  changing a value to the same value does not trigger anything.
  But if F<force> is C<true> even setting a model element to its
  current value triggers observers.

  | var val = cs(this).value("foo")
  | cs(this).value("foo", "bar")

  If you store arbitrary sub-structured values, you can make
  F<name> a path full specification based on the language supported
  by the M<select>() method:

  | var val = cs(this).value("foo.bar[1].baz['the-quux'])
  | cs(this).value("foo.bar[1].baz['the-quux']", "bar")

  In addition to the basic get/set operations on scalar values,
  you can also use array and hash operations on collections
  by using the F<operation> option. Supported F<operation>
  values are C<"get">, C<"set">, C<["splice",>offsetC<,>removeC<]>,
  C<"delete">, C<"push">, C<"pop">, C<"unshift"> and C<"shift">.
  The last four array operations are internally translated to the
  corresponding C<splice> operation. The arguments to the C<splice>
  operation are the same as for JavaScript's C<Array.prototype.splice>:
  "offset" is the 0-based offset into the array to operate at and
  "remove" is the number of elements to remove at "offset" (before
  the F<value> is added). The operations C<get>/C<set>/C<delete>
  operate on collection elements while the operations
  C<splice>/C<push>/C<pop>/C<unshift>/C<shift> operate on
  collections, hence you have to provide a path in F<name> which is suitable for them.
  The operations C<get>/C<set>/C<delete> can operate on both array and
  hash elements while C<splice>/C<push>/C<pop>/C<unshift>/C<shift> can operate on
  array objects only.

  | cs(this).value("foo.bar", [])
  | cs(this).value({ name: "foo.bar", operation: "push", value: "quux1" }) -> foo.bar: [ "quux1" ]
  | cs(this).value({ name: "foo.bar", operation: "push", value: "quux2" }) -> foo.bar: [ "quux1", "quux2" ]
  | cs(this).value({ name: "foo.bar", operation: "pop" }) -> foo.bar: [ "quux1" ]
  | cs(this).value({ name: "foo.bar", operation: "unshift", value: "quux2" }) -> foo.bar: [ "quux2", "quux1" ]
  | cs(this).value({ name: "foo.bar", operation: "unshift", value: "quux3" }) -> foo.bar: [ "quux3", "quux2", "quux1" ]
  | cs(this).value({ name: "foo.bar", operation: "shift" }) -> foo.bar: [ "quux2", "quux1" ]
  | cs(this).value({ name: "foo.bar", operation: [ "splice", 1, 0 ], value: "quux3" }) -> foo.bar: [ "quux2", "quux3", "quux1" ]
  | cs(this).value({ name: "foo.bar[1]", operation: "delete" }) -> foo.bar: [ "quux2", "quux1" ]
  | cs(this).value("foo.bar[0]") -> "quux2"
  | cs(this).value("foo.bar[1]") -> "quux1"
  | cs(this).value("foo.baz", {})
  | cs(this).value("foo.baz.quux1", "quux1") -> foo.baz: { quux1: "quux1" }
  | cs(this).value("foo.baz.quux2", "quux2") -> foo.baz: { quux1: "quux1", quux2: "quux2" }
  | cs(this).value({ name: "foo.baz.quux1", operation: "delete" }) -> foo.baz: { quux2: "quux2" }
  | cs(this).value("foo.baz.quux2") -> "quux2"

- O<component>.M<touch>({
      F<name>: T<String>,
  });
  O<component>.M<touch>(
      P<name>: T<String>
  )

  Touches the value of O<component>'s model element named F<name>,
  without changing the value but with triggering all its "get" observers
  (its "changed" observers are not triggered). This can be useful for
  firing "set" observers manually.

  | cs(this).touch("foo")

- O<component>.M<observe>({
      F<name>: T<String>,
      F<func>: T<Function>,
      [F<touch>: T<Boolean> = false,]
      [F<operation>: T<String> = "set",]
      [F<spool>: T<String> = null]
  }): T<Number>;
  O<component>.M<observe>(
      F<name>: T<String>,
      F<func>: T<Function>
  ): T<Number>

  Observe the value of O<component>'s model element named F<name>
  for F<operation> operations (by default "set" operations).
  For "get" operations, the callback function F<func> has to be of
  signature F<func>(P<ev>: T<Event>, P<value>: T<Object>): T<Void>.
  For "set" and "changed" operations, the callback function F<func> has to be of signature
  F<func>(P<ev>: T<Event>, P<value-new>: T<Object>, P<value-old>: T<Object>): T<Void>.
  Both types of callbacks can override the value by using P<ev>.M<result>(P<value>).
  The M<observe>() method returns an id which uniquely identifies the observation.
  Instead of having to manually release the observation later via M<unobserve>()
  you can use the spool mechanism and spool the corresponding M<unobserve>()
  operation via F<spool>.

  | id = cs(this).observe("state:username", function (ev, username) {
  |     ...
  | })

- O<component>.M<unobserve>({ F<id>: T<Number> }): T<Void>;
  O<component>.M<unobserve>(P<id>: T<Number>): T<Void>

  Release the observation identified by F<id>, previously acquired by a call to M<observe>().
  This is usually done implicitly through the spooling mechanism.

  | cs(this).unobserve(id)

Events
------

The Event mechanism is a central one in ComponentJS. Both
Models and Services are internally based on the Events mechanism.
An Event is an object published towards a target component. It is delivered
in 4 phases:

. In phase 1 (the "capturing" phase) the Event is delivered
  to all components on the path from the root component (inclusive) towards the target
  component (exclusive).
. In phase 2 (the "targeting" phase) the Event is delivered to the target component.
. In phase 3 (the "spreading" phase) the Event is delivered to all descendant components of
  the target component in a depth-first traversal order.
. In phase 4 (the "bubbling" phase) the Event is delivered (again) to all components on
  the path from the target component (exclusive) to the root component (inclusive).

Event objects are implicitly created by the M<publish>() operation and
they provide various getter/setter methods:

. M<target>() (T<Component>): target component the event is send to
. M<propagation>() (T<Boolean>): whether event propagation should continue
. M<processing>() (T<Boolean>): whether final default event processing should be performed
. M<dispatched>() (T<Boolean>): whether event was dispatched at least once to a subscriber
. M<decline>() (T<Boolean>): whether event was declined by subscriber
. M<state>() (T<Boolean>): state of dispatching: C<capturing>, C<targeting>, C<spreading> or C<bubbling>
. M<result>() (T<Object>): optional result value event subscribers can provide
. M<async>() (T<Boolean>): whether event is dispatched asynchronously

- O<component>.M<subscribe>({
      F<name>: T<String>,
      [F<spec>: T<Object> = C<{}>],
      [F<ctx>: T<Object> = O<component>,]
      F<func>: T<Function>,
      [F<args>: T<Object[]> = C<[]>],
      [F<capturing>: T<Boolean> = C<false>],
      [F<spreading>: T<Boolean> = C<false>],
      [F<bubbling>: T<Boolean> = C<true>],
      [F<noevent>: T<Boolean> = C<false>],
      [F<exclusive>: T<Boolean> = C<false>],
      [F<spool>: T<String> = C<null>]
  }): T<Number>;
  O<component>.M<subscribe>(
      P<name>: T<String>,
      P<func>: T<Function>,
      [P<args>: T<Object>, ...]
  ): T<Number>

  Subscribe to event F<name> (optionally sub-specified via F<spec>)
  on component O<component> and
  execute callback F<func> as F<func>C<(>P<ev>C<: >T<Event>
  C<, >P<args>C<: >T<Object>C<, ..., >P<sargs>C<: >T<Object>C<, ...)>
  once the event is dispatched to O<component> after it was published.
  By default an event is dispatched in the (mandatory) targeting and (optional) bubbling phases.

  . Option F<ctx> allows you to give "C<this>" a particular value for the
    callback F<func>. Option F<args> allows you to pass additional
    parameters to F<func> (before those passed by M<publish>().
  . Option F<noevent> does not pass the P<ev>: T<Event> parameter to F<func>.
  . Setting option F<capturing> to "C<true>" indicates that the event should
    be also dispatched in the capturing phase.
  . Setting option F<spreading> to "C<true>" indicates that the event should
    be also dispatched in the spreading phase.
  . Setting option F<bubbling> to "C<false>" indicates that the event should
    not be dispatched in the bubbling phase.
  . Option F<exclusive> can be set to "C<true>" for an exclusive subscription, i.e.,
    a subscription which prevents any subsequent subscriptions.

  The M<subscribe>() method returns an id which uniquely identifies the subscription.
  Instead of having to manually release the subscription later via M<unsubscribe>()
  you can use the spool mechanism and spool the corresponding M<unsubscribe>()
  operation via option F<spool>.

  | cs(self).subscribe({
  |     name: "data-loaded",
  |     spool: "prepared",
  |     func: function (ev, data, info) {
  |         ...
  |     }
  | })

- O<component>.M<unsubscribe>({ F<id>: T<Number> }): T<Void>;
  O<component>.M<unsubscribe>(P<id>: T<Number>): T<Void>

  Release the subscription identified by F<id>, previously acquired by a call to M<subscribe>().
  This is usually done implicitly through the spooling mechanism.

  | cs(this).unsubscribe(id)

- O<component>.M<subscription>({ F<id>: T<Number> }): T<Boolean>;
  O<component>.M<subscription>(P<id>: T<Number>): T<Boolean>

  Checks whether the subscription identified by F<id> exists on O<component>.

  | cs(this).subscription(id)

- O<component>.M<publish>({
      F<name>: T<String>,
      [F<spec>: T<Object> = C<{}>,]
      [F<async>: T<Boolean> = C<false>,]
      [F<capturing>: T<Boolean> = C<true>,]
      [F<spreading>: T<Boolean> = C<false>,]
      [F<bubbling>: T<Boolean> = C<true>,]
      [F<completed>: T<Function>,]
      [F<resultinit>: T<Object> = C<undefined>,]
      [F<resultstep>: T<Function>,]
      [F<directresult>: T<Boolean> = C<false>,]
      [F<noresult>: T<Boolean> = C<false>,]
      [F<firstonly>: T<Boolean> = C<false>,]
      [F<silent>: T<Boolean> = C<false>,]
      [F<args>: T<Object[]> = C<[]>]
  }): T<Object>;
  O<component>.M<publish>(
      P<name>: T<String>,
      P<args>...: T<Object>
  ): T<Object>

  Publishes an T<Event> to component O<component> named F<name> and with
  optional arguments F<args>. By default the event is intended to be
  dispatched in the (mandatory) targeting and (optional) capturing and
  bubbling phases. The following options allow you to further control
  the event publishing process:

  . Option F<spec> allows you to sub-specify/parametrize the event with
    arbitrary key/value pairs in case the F<name> is too generic.
  . Option F<async> allows the event processing to occur asynchronously.
  . Setting option F<capturing> to "C<false>" indicates that the event should
    not be intended to be dispatched in the capturing phase.
  . Setting option F<spreading> to "C<true>" indicates that the event should
    also be intended to be dispatched in the spreading phase.
  . Setting option F<bubbling> to "C<false>" indicates that the event should
    not be intended to be dispatched in the bubbling phase.
  . Option F<completed> executes the specified callback function
    once the event was dispatched to subscribers in all possible phases.
    This allows you to react at the end of F<async>=C<true> events.
  . Option F<resultinit> and F<resultstep>

  | cs(this).publish("data-loaded", data, info)

Services
--------

Services are loosely coupled method calls across components.
The functionality provider does M<register>() the service and
the functionality consumer does M<call>() the service.

- O<component>.M<register>({
      F<name>: T<String>,
      [F<ctx>: T<Object> = O<component>,]
      F<func>: T<Function>,
      [F<args>: T<Object[]> = C<[]>,]
      [F<spool>: T<String>,]
      [F<capturing>: T<Boolean> = C<false>,]
      [F<spreading>: T<Boolean> = C<false>,]
      [F<bubbling>: T<Boolean> = C<true>]
  }): T<Number>;
  O<component>.M<register>(
      P<name>: T<String>,
      P<func>: T<Function>
  ): T<Number>

  Register a service F<name> on O<component> with the implementing
  callback function F<func>. The function returns an identifier for
  M<unregister>(). The following options can be used to control the
  later service calls:

  . Option F<ctx> can be used to set the F<this> pointer for F<func>.
  . Option F<args> can be used to pass additional parameters to F<func> (before the F<args> of M<call>()!).
  . Option F<spool> can be used to spool the corresponding M<unregister>() call.
  . Option F<capturing> can be set to C<true> to provide the service also in the "capturing" phase.
  . Option F<spreading> can be set to C<true> to provide the service also in the "spreading" phase.
  . Option F<bubbling> can be set to C<false> to not provide the service in the "bubbling" phase.

  | var id = cs(this).register({
  |     name: "load-entity",
  |     args: [ em ],
  |     func: function (em, clazz, id) {
  |         return em.findById(clazz, id);
  |     }
  | })

- O<component>.M<unregister>({ F<id>: T<Number> }): T<Void>;
  O<component>.M<unregister>(P<id>: T<Number>): T<Void>

  Release the registration identified by F<id>, previously acquired by a call to M<register>().
  This is usually done implicitly through the spooling mechanism.

  | cs(this).unregister(id)

- O<component>.M<registration>({ F<id>: T<Number> }): T<Boolean>;
  O<component>.M<registration>(P<id>: T<Number>): T<Boolean>

  Checks whether the registration identified by F<id> exists on O<component>.

  | cs(this).registration(id)

- O<component>.M<callable>({ F<name>: T<String>[, F<value>: T<Boolean>] }): T<Boolean>;
  O<component>.M<callable>(P<name>: T<String>[, P<value>: T<Boolean>]): T<Boolean>

  Checks whether a registered service is callable/enabled or enable/disable
  a registered service. On every change to the "callable" status of a service,
  an internal event named "C<ComponentJS:service:>F<name>C<:callable>" is
  published with two arguments: the new and old boolean value.

  | cs(this).subscribe("ComponentJS:service:load-person:callable", function (old, new) {
  |     if (new) {
  |         /* react on now callable service  */
  |     }
  | })
  | cs(this).callable("load-person", false)
  | cs(this).callable("load-person", true)

- O<component>.M<call>({
      F<name>: T<String>,
      [F<args>: T<Object[]> = C<[]>,]
      F<capturing>: T<Boolean> = C<false>,]
      F<spreading>: T<Boolean> = C<false>,]
      F<bubbling>: T<Boolean> = C<true>]
  }): T<Object>;
  O<component>.M<call>(
      P<name>: T<String>
      [, P<args>...: T<Object>]
  ): T<Object>

  Call service named F<name> on component O<component>, optionally
  passing it the arguments F<args> (after the optional F<args> of
  M<register>()!). The following options can be used to control the
  service call:

  . Option F<capturing> can be set to C<true> to deliver the underlying service event also in the "capturing" phase.
  . Option F<spreading> can be set to C<true> to deliver the underlying service event also in the "spreading" phase.
  . Option F<bubbling> can be set to C<false> to not deliver the underlying service event in the "bubbling" phase.

  | var person = cs("/sv").call("load-entity", "Person", 42)

